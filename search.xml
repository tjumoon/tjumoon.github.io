<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【译】Go包风格指南]]></title>
    <url>%2F2018%2F05%2F04%2FStyle-guideline-for-Go-packages%2F</url>
    <content type="text"><![CDATA[本文翻译至Style guideline for Go packages GO与语言中的所有其他事物一样命名和组织。结构良好的Go代码可以很容易被发现，使用和阅读。一个结构良好的代码如同与一个设计良好的API接口一样重要。位置、命名、以及包结构是你的用户首先看到并与其打交道的。 本文的目标是用一些最佳实践来指导你而不是设置规则。读者可以根据自己的判断来选择最优雅的方案来应对特殊的场景。 包所有Go代码都是以包的形式组织在一起的。Go语言中的包就是一个简单的目录/文件夹，里面包含一个或多个.go文件。Go语言使用包来管理、组织代码，就如同计算机通过目录/文件夹来组织文件一样。 所有的Go代码都是放在包里的，Go语言的包是访问Go代码的入口。理解和建立良好的包组织实践对于写出高效的Go代码是非常重要的 包组织让我们从如何组织Go代码以及解释如何设置Go包开始。 使用多文件一个包就是一个里面包含一个或者多个Go文件的目录。尽情将你的代码按照逻辑划分到多个文件中以获得最佳的可读性。 例如，一个HTTP包可以根据HTTP功能方面划分到不同文件中。在下面的例子中，一个HTTP包被划分为多个文件：header类型和代码，cookie类型和代码，HTTP实现以及包的文档。 1234- doc.go // package documentation- headers.go // HTTP headers types and code- cookies.go // HTTP cookies types and code- http.go // HTTP client implementation, request and response types, etc. ####保持类型靠近 一般来说，我们要让类型定义靠近他使用的地方。这可以很方便维护人员（不仅仅是原始作者）发现类型。对于一个Header类型，一个好的实现是把他放在header.go文件中。 12345$ cat headers.gopackage http// Header represents an HTTP header.type Header struct &#123;...&#125; 尽管，Go语言不限制你在何处定义你的类型，通常我们最好是将核心类型放在文件的顶部。 根据功能组织代码通常在其他语言中，我们将类型放在一个叫做models或者types的包中。但在Go语言中，我们依据他的功能来组织代码 1234package models // DON'T DO IT!!!// User represents a user in the system.type User struct &#123;...&#125; User类型应该放在服务层包中，而不是创建一个models包，然后让将所有实体类型定义在其中。 12345678package mngtservice// User represents a user in the system.type User struct &#123;...&#125;func UsersByQuery(ctx context.Context, q *Query) ([]*User, *Iterator, error)func UserIDByEmail(ctx context.Context, email string) (int64, error) 使用godoc一个比较好的做法是，在设计你的包接口阶段，用godoc来定义你将要设计的概念。有时，可视化对设计也有影响。Godoc是用户使用一个包的一个方式，因此，你需要稍作调整让他们更容易被接受。运行godoc -http=&lt;hostport&gt;来本地启动一个godoc服务 提供一些范列很多时候，你不可能将所有相关的类型放在一个包中。您可能希望从单独的包发布公用接口的具体实现，或者这些类型可能被第三方包所拥有。提供一些例子可以帮助用户去发现、理解如何使用他们。 123$ godoc cloud.google.com/go/datastorefunc NewClient(ctx context.Context, projectID string, opts ...option.ClientOption) (*Client, error)... NewClient works with option.ClientOptions but it is neither the datastore package nor the option package that export all the option types. 123$ godoc google.golang.org/extraoptionfunc WithCustomValue(v string) option.ClientOption... 如果你的API需要引入许多非标准的包，通常提供一些可运行的代码是一个比较好的做法。 包命名包的名称和路径即是包的重要标识同时也表示包中所含内容。规范的命名不仅能提高你的代码质量而且可以提供你的用户的代码质量。 小写包名必须小写。不要使用下划线、驼峰在你的包名中。comprehensive guide这边博客有许多关于包命名的范例。 简短，但是语意明确包名应该比较简单，但是是唯一且语意明确的。用户可以通过报名就能了解到他的用途。 避免过于宽泛的包名，如：common、util。 1import "pkgs.org/common" // DON'T!!! 在可能导入相同包的情况下避免重复的命名。 如果你不能避免糟糕的命名，那么很可能你的代码组织结构出现了问题。 导入路径简洁避免将自定义存储结构暴露给用户。像GOPATH一样。避免在你的导入路径中出现src/、pkg/等。 123github.com/user/repo/src/httputil // DON'T DO IT, AVOID SRC!!github.com/user/repo/gosrc/httputil // DON'T DO IT, AVOID GOSRC!! 不要使用复数在Go语言中，包名不要使用复数。对于许多其他语言的开发人员来说，这很惊讶，他们一直使用复数来命名。不是使用httputils，而用httputil。 1package httputils // DON'T DO IT, USE SINGULAR FORM!! 重命名需要遵循相同的规则假如你导入多个具有相同名字的包，你可以重命名包的名字。重命名应该使用相同的规则。关于重命名没有具体的规则。假如你重命名一个标准库名，最好在前面加上go以标识这是Go标准库的包。如：gourl，goioutil。 12345import ( gourl "net/url" "myother.com/url")]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-学习日记]]></title>
    <url>%2F2018%2F03%2F01%2F2018-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2018-03-06 《MySQL必知必会》 2018-04-13 《Web Development With Go》 2018-04-20 《三体》]]></content>
      <tags>
        <tag>学习季</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo建站之路]]></title>
    <url>%2F2018%2F02%2F06%2Fhexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前因前一段时间，折腾了一下，搞了个自己的博客。基于Hexo，网上有一大堆教程，一步步教你怎么来搭建一个自己的博客，有需要的小伙伴可以自行百度，当然其中也遇到了一些问题。先说下我的最终方案把Hexo + Next主题 + Travis CI自动化部署 + GitHubPages &amp; CodingPages双托管。 Travis CI自动化部署Travis CI可以自动监听代码变化，并自动编译，发布。所以说，每次，我们只需要将源代码push到github，Travis CI会自动帮我们发布，非常方便。 所以，我们需要两个分支： blog-source——用于托管我们源代码 master——用于发布代码 不清楚的同学可以自行百度如何用Travis CI自动化发布Hexo博客，网上有一些Travis脚本，比如： 123456789101112131415161718192021222324252627282930language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm install#before_script: # - npm install -g gulpscript: - hexo gafter_script: - cd ./public - git init - git config user.name "lifengsofts" - git config user.email "lifengsofts@gmail.com" - git add . - git commit -m "Update docs" - git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:master# E: Build LifeCyclebranches: only: - blog-sourceenv: global: - GH_REF: github.com/lifengsofts/lifengsofts.github.io.git 简单解释下这段代码把： 12language: node_jsnode_js: stable 这段是指定使用node.js版本 123# S: Build Lifecycleinstall: - npm install 根据package.json安装node.js依赖 123456branches: only: - blog-sourceenv: global: - GH_REF: github.com/lifengsofts/lifengsofts.github.io.git 指定需要编译的source分支 12script: - hexo g 执行命令，生成Hexo静态文件 123456789after_script: - cd ./public - git init - git config user.name "lifengsofts" - git config user.email "lifengsofts@gmail.com" - git add . - git commit -m "Update docs" - git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:master# E: Build LifeCycle 这段复杂一点，意思是，进入Hexo静态发布文件，配置github信息，通过git push推送到master分支，这样就搞定了，完全没有问题 百度sitemap与SEO优化如上面所说，这样我们的博客就建立好了，可以正常访问，可以绑定自己的域名信息，可是遇到两个问题。 既然我们做了博客，当然是希望可以让更多的人访问到，所以我们需要做SEO优化，我们希望自己的网站可以被百度，Google等搜索引擎收录 GitHub服务器是在国外的，国内访问很慢，有时候甚至需要翻墙才能打开 百度有三种自动提交方式：主动推送, 自动推送, sitemap，一个个说，每个里面都有坑 主动提交网上一位大神，写了一个Hexo的插件hexo-baidu-url-submit 安装: Hexo根目录，安装此插件1npm install hexo-baidu-url-submit --save 配置: 同样在根目录下，把以下内容配置到_config.yml文件中12345baidu_url_submit: count: 3 ## 比如3，代表提交最新的三个链接 host: simonblog.cn ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 域名配置：同样在_config.yml文件中1234# URLurl: http://simonblog.cnroot: /permalink: :year/:month/:day/:title/ 一定要注意，你配置的域名必须与你在百度站长平台中注册的域名一致，如果有www就都要有，如果没有就都没有 最后，加入新的deployer1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: - type: git repo: github: https://__GH_TOKEN__@github.com/tjumoon/tjumoon.github.io.git,master - type: baidu_url_submitter 执行hexo deploy的时候就会主动提交你的sitemap 但是，我试了半天，发现没有提交，什么原因，好忧伤，大神的代码有bug？查代码把！ 在hexo-baidu-url-submit的index.js中，我们看到 12hexo.extend.generator.register('baidu_url_generator', require('./lib/generator'));hexo.extend.deployer.register('baidu_url_submitter', require('./lib/submitter')); 在执行hexo generator时加载了generator模块 在执行hexo deploy时加载了submitter模块 继续看generator干了什么 1234567891011121314151617181920212223242526272829303132module.exports = function (locals) &#123; var log = this.log; var config = this.config; var count = config.baidu_url_submit.count; var urlsPath = config.baidu_url_submit.path; log.info("Generating Baidu urls for last " + count + " posts"); // get last posts var urls = [].concat(locals.posts.toArray()) .map(function(post) &#123; return &#123; "date": post.date, "permalink": post.permalink &#125; &#125;) .sort(function(a, b) &#123; return b.date - a.date; &#125;) .slice(0, count) .map(function(post) &#123; return post.permalink &#125;) .join('\n'); log.info("Posts urls generated in " + urlsPath + "\n" + urls); return &#123; path: urlsPath, data: urls &#125;;&#125;; 其实就是读取你_posts里的文件，生成baidu_urls.txt 再看submitter里做了什么 12345678910111213141516171819202122232425262728var pathFn = require('path');var fs = require('fs');var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;module.exports = function(args) &#123; var log = this.log; var config = this.config; var urlsPath = config.baidu_url_submit.path; var host = config.baidu_url_submit.host; var token = config.baidu_url_submit.token; var publicDir = this.public_dir; var baiduUrlsFile = pathFn.join(publicDir, 'baidu_urls.txt'); var urls = fs.readFileSync(baiduUrlsFile, 'utf8'); log.info("Submitting urls \n" + urls) var target = "http://data.zz.baidu.com/urls?site=" + host + "&amp;token=" + token; var xhr = new XMLHttpRequest(); xhr.open('POST', target, false); xhr.setRequestHeader('Content-type', 'text/plain'); xhr.onload = function () &#123; console.log(this.responseText); &#125;; xhr.send(urls);&#125;; 就是读取baidu_urls.txt,通过xhr推送给百度。 好吧，问题找到了。 123456789101112script: - hexo g after_script: - cd ./public - git init - git config user.name "lifengsofts" - git config user.email "lifengsofts@gmail.com" - git add . - git commit -m "Update docs" - git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:master# E: Build LifeCycle 我们可以看到，我们只执行了hexo g，并没有执行hexo deploy，而是手动通过git push将代码提交到master分支，所以，并没有加载submitter模块，所以根本就没有提交。 最终我的配置文件 _config.yml 1234567891011121314# Baidu sitemapbaidu_url_submit: count: 10 ## 提交最新的一个链接 host: simonblog.cn ## 在百度站长平台中注册的域名 token: your-token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: - type: git repo: github: https://__GH_TOKEN__@github.com/tjumoon/tjumoon.github.io.git,master - type: baidu_url_submitter 我们来看下hexo deploy做了什么，其实做了两件事 提交本地文件到master分支 执行baidu_url_submitter .travis.yml 1234567891011121314151617181920212223242526language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm installbefore_script: - git config user.name "tjumoon" - git config user.email "simon_yang@aliyun.com" - sed -i "s/__GH_TOKEN__/$&#123;GH_TOKEN&#125;/" _config.yml script: - hexo clean - hexo gafter_success: - hexo deploybranches: only: - blog-sourceenv: global: - GH_REF: github.com/tjumoon/tjumoon.github.io.git 自动提交自动提交比较简单，在next主题配置_config.yml中设置 1baidu_push: true 继续看代码：themes\next\layout\_third-party\seo\baidu-push.swig 12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; 这里添加了一段发送的js代码，一定要注意你配置的域名必须要与你百度站长在的域名一致 sitemap百度站长平台，提交sitemap后，百度会自动去爬取你的sitemap 这里需要安装插件 12npm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save 同样，这两个插件会在hexo generator的时候自动创建baidusitemap.xml，sitemap.xml 接下来，我们在百度站长上提交sitemap吧 但是，每次都是抓去失败，403 Forbidden，什么原因。百度了一下，发现github默认会屏蔽来自百度的爬虫。这怎么解决….. 好吧，既然github屏蔽百度，那我们就增加一个托管平台——Coding，基本配置思路和github一致，最终的配置脚本 _config.yml 123456789101112131415# Baidu sitemapbaidu_url_submit: count: 10 ## 提交最新的一个链接 host: simonblog.cn ## 在百度站长平台中注册的域名 token: your-token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: - type: git repo: github: https://__GH_TOKEN__@github.com/tjumoon/tjumoon.github.io.git,master coding: https://simon_yang:__CODING_TOKEN__@git.coding.net/simon_yang/Blog.git,master - type: baidu_url_submitter .travis.yml 123456789101112131415161718192021222324252627language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm installbefore_script: - git config user.name "tjumoon" - git config user.email "simon_yang@aliyun.com" - sed -i "s/__GH_TOKEN__/$&#123;GH_TOKEN&#125;/" _config.yml - sed -i "s/__CODING_TOKEN__/$&#123;CODING_TOKEN&#125;/" _config.ymlscript: - hexo clean - hexo gafter_success: - hexo deploybranches: only: - blog-sourceenv: global: - GH_REF: github.com/tjumoon/tjumoon.github.io.git 然后，我们在域名服务器上配置，国内流量访问CodingPage，海外流量访问GithubPage，完美解决百度爬虫问题，同时网站的打开速度大大提升了 最后本篇文章，不是一个搭建教程，只是在搭建过程中遇到的问题，以及如何解决的一些思路]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】RxSwift-那些难以理解的细节]]></title>
    <url>%2F2018%2F01%2F30%2FRxSwift-%E9%82%A3%E4%BA%9B%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[此文转载至【田腾飞的博客】 上一篇文章RxSwift-各种概念解读内容比较多，文章简直是太长了，我都难以坚持看下去😂，建议大家粗略读一遍就行了，用到的时候来查一下，慢慢地就掌握了。 这篇文章接着上篇文章，主要来深入了解一些RxSwift实战中用到的一些重要知识点，这里面有很多自己的理解和思考，包含很多网上几乎收不到的内容，希望会是大家研究官方例子的一个重要参考资料，文章中不免会有些错误的地方，也请大家能多多留言交流，一起成长。这两篇文章过后，准备写实战教程，希望大家多多关注吧。let’s go Rx系列的核心就是Observable Sequence这个相信大家心中已经有所了解了，这里不再啰嗦了，建议大家看看我都上一篇文章去了解一下。 Disposing当监听一个事件序列的时候，有消息事件来了，我们做某些事情。但是这个事件序列不再发出消息了，我们的监听也就没有什么存在价值了，所以我们需要释放我们这些监听资源，其实也就是每种编程语言中的内存资源释放。OC和Swift中也一样，在你不需要用某些变量的时候，你需要把这些变量所占用的内存空间释放掉。 释放某一个监听的时候我们可以手动调用释放方法，但是这个貌似一般不常用： 12345678910// 关于scheduler，我们会在下面讲到let subscription = Observable&lt;Int&gt;.interval(0.3, scheduler: SerialDispatchQueueScheduler.init(internalSerialQueueName: "test")) .observeOn(MainScheduler.instance) //observeOn也会在下面讲到 .subscribe &#123; event in print(event)&#125; Thread.sleep(forTimeInterval: 2.0) subscription.dispose() 123456next(0)next(1)next(2)next(3)next(4)next(5) 比如上面这个例子，我们创建了一个subscription监听，在两秒以后我们不需要了，手动调用dispose()方法，就能释放监听资源，不再打印信息。上面的subscription不伦是在哪个线程中监听，就算在主线程中调用的dispose()方法一样会销毁资源。 Dispose Bag除了上面手动的方法，还有一种是自动的方式，推荐大家使用这种方式，这种方式就好像iOS中的ARC方式似得，会自动去释放资源。 1234567let disposeBag = DisposeBag() Observable&lt;Int&gt;.empty() .subscribe &#123; event in print(event) &#125; .addDisposableTo(disposeBag) 如上个例子，我们创建一个disposeBag来盛放我们需要管理的资源，然后把新建的监听都放进去，会在适当的时候销毁这些资源。如果你需要立即释放资源只需要新建一个DisposeBag()，那么上一个DisposeBag就会被销毁。 observeOn()和subscribeOn()这两个东西可能很多人看官方文档说的一头雾水，就知道最好多用observeOn()，但说明不了为啥。下面咱们就谈谈这俩货到底有啥区别。 区别其实我感觉其实就一句话，subscribeOn()设置起点在哪个线程，observeOn()设置了后续工作在哪个线程。例如： 12345678someObservable .doOneThing() 1 .observeOn(MainRouteScheduler.instance) 2 .subscribeOn(OtherScheduler.instance) 3 .subscribeNext &#123; 4 ...... &#125; .addDisposableTo(disposeBag) 所有动作都发生在当前的默认线程 observeOn转换线程到主线程，下面所有的操作都是在主线程中 subscribeOn规定动作一开始不是发生在默认线程了，而是在OtherScheduler了。 如果我们之前没有调用observeOn，那么这边会在OtherScheduler发生，但是我们前面调用了observeOn，所以这个动作会在主线程中调用。 总结一下：subscribeOn只是影响事件链开始默认的线程，而observeOn规定了下一步动作发生在哪个线程中。 shareReplay可能你看官方demo的时候，会有迷惑，为啥很多序列后面会有shareReplay(1)呢？，想的头昏脑胀的。请先看下面例子： 123456789101112let testReplay = Observable.just("😂") .map &#123; print($0) &#125; testReplay .subscribe &#123; event in print(event)&#125;.addDisposableTo(disposeBag) testReplay .subscribe &#123; event in print(event)&#125;.addDisposableTo(disposeBag) 123456😂next(())completed😂next(())completed 大家发现没，map函数执行了两遍，但是有些时候我不需要map函数里的东西执行两遍，比如map函数里面如果执行的是网络请求，我只需要一次请求结果供大家使用就行了，多余的请求没啥用，浪费时间。所以这时候就需要shareReplay(1)了。这里面的数字一般都是1，只执行一次。你可以改为2，3看看结果有啥不同哦。 12345678910111213let testReplay = Observable.just("😂") .map &#123; print($0) &#125; .shareReplay(1) testReplay .subscribe &#123; event in print(event)&#125;.addDisposableTo(disposeBag) testReplay .subscribe &#123; event in print(event)&#125;.addDisposableTo(disposeBag) 12345😂 //只执行了一次next(())completednext(())completed 自定义operator自定义操作符很简单，官方推荐尽量用标准的操作符，但是你也可以自定义自己的操作符，文档上说有两种方法，这里我们只说一下最常用的一种方法。 例如我们自定义一个map操作符： 12345678910111213141516171819extension ObservableType &#123; func myMap&lt;R&gt;(transform: E -&gt; R) -&gt; Observable&lt;R&gt; &#123; return Observable.create &#123; observer in let subscription = self.subscribe &#123; e in switch e &#123; case .next(let value): let result = transform(value) observer.on(.next(result)) case .error(let error): observer.on(.error(error)) case .completed: observer.on(.completed) &#125; &#125; return subscription &#125; &#125;&#125; 参数是一个闭包，其中闭包参数是E类型返回值是R类型，map函数的返回值是一个Observable类型。 DriverDriver是啥东东？Driver功能很吊，讲解Driver之前我们现在看看下面的例子。 12345678910111213141516let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) &#125;results .map &#123; "\($0.count)" &#125; .bindTo(resultCount.rx.text) .addDisposableTo(disposeBag)results .bindTo(resultsTableView.rx.items(cellIdentifier: "Cell")) &#123; (_, result, cell) in cell.textLabel?.text = "\(result)" &#125; .addDisposableTo(disposeBag) 首先创建一个可监听序列results，其中flatMapLatest怎么用我们下面讲 然后将results绑定到resultCount.rx.text上 将results绑定到resultsTableView上 上面程序会有下面几个异常情况 如果上面fetchAutoCompleteItems出错了，那么他绑定的UI将不再收到任何事件消息 如果上面fetchAutoCompleteItems是在后台某个线程中运行的，那么事件绑定也是发生在后台某个线程，这样更新UI的时候会造成crash 有两次绑定fetchAutoCompleteItems会执行两次 当然针对上面问题我们也有解决方案，我们可以使用神器shareReplay(1)保证不会执行两次，可以使用observeOn()保证后面所有操作在主线程完成。 12345678910111213141516171819let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .observeOn(MainScheduler.instance) .catchErrorJustReturn([]) &#125; .shareReplay(1) results .map &#123; "\($0.count)" &#125; .bindTo(resultCount.rx.text) .addDisposableTo(disposeBag)results .bindTo(resultTableView.rx.items(cellIdentifier: "Cell")) &#123; (_, result, cell) in cell.textLabel?.text = "\(result)" &#125; .addDisposableTo(disposeBag) 但是你也可以使用Driver 1234567891011121314151617let results = query.rx.text.asDriver() //转换成一个Driver序列 .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .asDriver(onErrorJustReturn: []) //当遇见错误需要返回什么 &#125; //不需要添加shareReplay(1)results .map &#123; "\($0.count)" &#125; .drive(resultCount.rx.text) //和bingTo()功能一样 .addDisposableTo(disposeBag) results .drive(resultTableView.rx.items(cellIdentifier: "Cell")) &#123; (_, result, cell) in cell.textLabel?.text = "\(result)" &#125; .addDisposableTo(disposeBag) drive方法只能在Driver序列中使用，Driver有以下特点：1 Driver序列不允许发出error，2 Driver序列的监听只会在主线程中。所以Driver是转为UI绑定量身打造的东西。以下情况你可以使用Driver替换BindTo: 不能发出error 在主线程中监听 共享事件流 map和flatMap何时使用大家看官方Demo的时候，可能会迷惑为啥有的地方使用flatMapLatest为啥有些地方使用map呢？比如上面那个Driver所用的例子。 map函数，接受一个R类型的序列，返回一个R类型的序列，还是原来的序列 1public func map&lt;R&gt;(_ transform: @escaping (Self.E) throws -&gt; R) -&gt; RxSwift.Observable&lt;R&gt; flatMap函数，接收一个O类型的序列，返回一个O.E类型的序列，也就是有原来序列里元素组成的新序列。 1public func flatMap&lt;O : ObservableConvertibleType&gt;(_ selector: @escaping (Self.E) throws -&gt; O) -&gt; RxSwift.Observable&lt;O.E&gt; 其实这里的map和flatMap在swift中的作用是一样的。map函数可以对原有序列里面的事件元素进行改造，返回的还是原来的序列。而flatMap对原有序列中的元素进行改造和处理，每一个元素返回一个新的sequence，然后把每一个元素对应的sequence合并为一个新的sequence序列。 看下面例子： 12345678let test = Observable.of("1", "2", "3", "4", "5") .map &#123; $0 + "TTF" &#125; test .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123451TTF2TTF3TTF4TTF5TTF 我们使用map对序列中每一个元素进行了处理，返回的是一个元素，而使用flatMap需要返回的序列。那么使用map也返回一个序列看看。 12345678let test = Observable.of("1", "2", "3", "4", "5") .map &#123; Observable.just($0) &#125;test .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 12345RxSwift.Just&lt;Swift.String&gt;RxSwift.Just&lt;Swift.String&gt;RxSwift.Just&lt;Swift.String&gt;RxSwift.Just&lt;Swift.String&gt;RxSwift.Just&lt;Swift.String&gt; 看到结果会打印出每一个序列，下面我们使用merge()方法将这几个序列进行合并 123456789let test = Observable.of("1", "2", "3", "4", "5") .map &#123; Observable.just($0) &#125; .merge() test .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 1234512345 合并为一个新序列后我们就可以正常打印元素了。下面看看使用faltMap()函数干这件事 12345678let test = Observable.of("1", "2", "3", "4", "5") .flatMap &#123; Observable.just($0) &#125; test .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 1234512345 看下对比是不是一样，这样子对比就清晰了吧。 map函数只能返回原来的那一个序列，里面的参数的返回值被当做原来序列中所对应的元素。 flatMap函数返回的是一个新的序列，将原来元素进行了处理，返回这些处理后的元素组成的新序列 map函数 + 合并函数 = flatMap函数 flatMap函数在实际应用中有很多地方需要用到，比如网络请求，网络请求可能会发生错误，我们需要对这个请求过程进行监听，然后处理错误。只要继续他返回的是一个新的序列。 1234567validatedUsername = input.username .flatMapLatest &#123; username in return validationService.validateUsername(username) .observeOn(MainScheduler.instance) .catchErrorJustReturn(.failed(message: "Error contacting server")) &#125; .shareReplay(1) flatMapLatest其实就是flatMap的另一个方式，只发送最后一个合进来的序列事件。上面认证username是一个网络请求，我们需要对这个过程进行处理。 12345validatedPassword = input.password .map &#123; password in return validationService.validatePassword(password) &#125; .shareReplay(1) 这个password不需要后台联网认证，只需要返回password符合不符合要求就行了，还是原来的序列就行了。 flatMap也解决了内嵌多个subscribe的问题，官方不建议内嵌多个subscribe。比如： 1234567textField.rx_text.subscribe(onNext: &#123; text in performURLRequest(text).subscribe(onNext: &#123; result in ... &#125;) .addDisposableTo(disposeBag)&#125;).addDisposableTo(disposeBag) 改写为flatMap 123456textField.rx_text .flatMapLatest &#123; text in return performURLRequest(text) //因为flatMap返回一个新的sequence &#125; ... .addDisposableTo(disposeBag) 再举一个例子，当我们网络请求得到json数据的时候，我们可以使用flatmap进行序列转换，解析成Model序列，然后我们订阅这个带有Model的序列，代码就会变得很优雅。具体可以参考文章Moya+RxSwift进行更优雅的网络请求 好了，相信大家对这俩货有了一个清晰的认识了吧。 UIBindingObserverUIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwiftz中对UIKit的一个扩展库)给的扩展不够我们使用，比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做： 1234567extension Reactive where Base: UITextField &#123; var inputEnabled: UIBindingObserver&lt;Base, Result&gt; &#123; return UIBindingObserver(UIElement: base) &#123; textFiled, result in textFiled.isEnabled = result.isValid &#125; &#125;&#125; UIBindingObserver是一个类，他的初始化方法中，有两个参数，第一个参数是一个元素本身，第一个参数是一个闭包，闭包参数是元素本身，还有他的一个属性。 1public init(UIElement: UIElementType, binding: @escaping (UIElementType, Value) -&gt; Swift.Void) 自定义了一个inputEnabled Observer里面关联的UITextField的isEnabled属性。 好了，文章到这里也差不多了，这篇文章中没有实战教程，但绝对都是干货，也许在你专研官方demo的时候看不懂某个写法，看了这篇文章你就会豁然开朗了呢？🙄]]></content>
      <tags>
        <tag>RxSwift</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】RxSwift-你所需要知道的各种概念]]></title>
    <url>%2F2018%2F01%2F30%2FRxSwift-%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%90%84%E7%A7%8D%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[此文转载至【田腾飞的博客】 相信大家很早就听说过函数式响应编程概念，我是去年面试的时候接触到函数式响应编程的，当时也是第一次接触到MVVM这个概念，转眼都一年过去了，我却没有在函数式响应编程上做深入的研究，说来还真是惭愧。 不过最近由于想要使用RxSwift，所以趁这个时候好好接触和研究一下传说中的函数式响应编程，由于网上关于RxSwift的教程资料很少，这篇文章其实就是最RxSwift官方文档和一些概念做一些解读。算是大家学习的参考文章吧！ 先挖个坑，这可能会是一个RxSwift系列，希望大家在学习的时候有所参考。 RxSwift是什么RxSwif是ReactiveX的Swift版本，也就是一个函数式响应编程的框架。对，就这一句话。想要知道他做什么的，我们先来了解一下观察者模式。 观察者模式关于观察者模式我想大伙应该都很了解了吧，什么KVO，通知等都是观察者模式，在设计模式中他可是一个重中之重的设计模式啊！比如一个宝宝在睡觉，爸爸妈妈，爷爷奶奶总不能在那边一只看着吧？那样子太累了。他们该做啥事就做啥事呗，只要听到宝宝的哭声，他们就给宝宝喂奶就行了。这就是一个典型的观察者模式。宝宝是被观察者，爸爸妈妈等是观察者也称作订阅者，只要被观察者发出了某些事件比如宝宝哭声、叫声都是一个事件，通知到订阅者，订阅者们就可以做相应的处理工作。哈哈，观察者模式很简单吧？ RxSwift做了什么RxSwift把我们程序中每一个操作都看成一个事件，比如一个TextField中的文本改变，一个按钮被点击，或者一个网络请求结束等，每一个事件源就可以看成一个管道，也就是sequence，比如TextField，当我们改变里面的文本的时候，这个TextField就会不断的发出事件，从他的这个sequence中不断的流出，我们只需要监听这个sequence，每流出一个事件就做相应的处理。同理，Button也是一个sequence，每点击一次就流出一个事件。也就是我们把每一步都想成是一个事件就好去理解RxSwift了。看下图是不是很好理解了？ Observable和Observer理解了观察者模式这两个概念就很好理解了，Observable就是可被观察的，也就是我们说的宝宝，他也是事件源。而Observer就是我们的观察者，也就是当收到事件的时候去做某些处理的爸爸妈妈。观察者需要去订阅(subscribe)被观察者，才能收到Observable的事件通知消息。 下面开始一些基本概念解读，通读一遍你会对RxSwift有非常深刻的认识了，其实也就是对整理了一下官方文档和加上自己的一些理解 创建和订阅被观察者下面创建被观察者其实就是创建一个Obserable的sequence，就是创建一个流，然后就可以被订阅subscribe，这样被观察者发出事件消息，我们就能做相应的处理 DisposeBagDisposeBag其实就相当于iOS中的ARC，会在适当的时候销毁观察者，相当于内存管理者吧。 subscribesubscribe是订阅sequence发出的事件，比如next事件，error事件等。而subscribe(onNext:)是监听sequence发出的next事件中的element进行处理，他会忽略error和completed事件。相对应的还有subscribe(onError:) 和 subscribe(onCompleted:) nevernever就是创建一个sequence，但是不发出任何事件信号。 1234567let disposeBag = DisposeBag()let neverSequence = Observable&lt;String&gt;.never() let neverSequenceSubscription = neverSequence .subscribe &#123; _ in print("This will never be printed")&#125;.addDisposableTo(disposeBag) 1结果是什么都不打印 emptyempty就是创建一个空的sequence,只能发出一个completed事件 1234567let disposeBag = DisposeBag() Observable&lt;Int&gt;.empty() .subscribe &#123; event in print(event) &#125; .addDisposableTo(disposeBag) 1completed justjust是创建一个sequence只能发出一种特定的事件，能正常结束 1234567let disposeBag = DisposeBag() Observable.just("🔴") .subscribe &#123; event in print(event) &#125; .addDisposableTo(disposeBag) 12next(🔴)completed ofof是创建一个sequence能发出很多种事件信号 1234567let disposeBag = DisposeBag() Observable.of("🐶", "🐱", "🐭", "🐹") .subscribe(onNext: &#123; element in print(element) &#125;) .addDisposableTo(disposeBag) 1234🐶🐱🐭🐹 如果把上面的onNext:去掉的话，结果会是这样子，也正好对应了我们subscribe中，subscribe只监听事件。 12345next(🐶)next(🐱)next(🐭)next(🐹)completed fromfrom就是从集合中创建sequence，例如数组，字典或者Set 12345let disposeBag = DisposeBag() Observable.from([&quot;🐶&quot;, &quot;🐱&quot;, &quot;🐭&quot;, &quot;🐹&quot;]) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) create我们也可以自定义可观察的sequence，那就是使用create create操作符传入一个观察者observer，然后调用observer的onNext，onCompleted和onError方法。返回一个可观察的obserable序列。 12345678910111213let disposeBag = DisposeBag() let myJust = &#123; (element: String) -&gt; Observable&lt;String&gt; in return Observable.create &#123; observer in observer.on(.next(element)) observer.on(.completed) return Disposables.create() &#125;&#125; myJust("🔴") .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) 12next(🔴)completed rangerange就是创建一个sequence，他会发出这个范围中的从开始到结束的所有事件 12345let disposeBag = DisposeBag() Observable.range(start: 1, count: 10) .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) 1234567891011next(1)next(2)next(3)next(4)next(5)next(6)next(7)next(8)next(9)next(10)completed repeatElement创建一个sequence，发出特定的事件n次 123456let disposeBag = DisposeBag() Observable.repeatElement("🔴") .take(3) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123🔴🔴🔴 generategenerate是创建一个可观察sequence，当初始化的条件为true的时候，他就会发出所对应的事件 123456789let disposeBag = DisposeBag() Observable.generate( initialState: 0, condition: &#123; $0 &lt; 3 &#125;, iterate: &#123; $0 + 1 &#125; ) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123012 deferreddeferred会为每一为订阅者observer创建一个新的可观察序列 下面例子中每次进行subscribe的时候都会去创建一个新的deferredSequence，所以Emitting会打印两遍。 1234567891011121314151617181920212223let disposeBag = DisposeBag()var count = 1 let deferredSequence = Observable&lt;String&gt;.deferred &#123; print("Creating \(count)") count += 1 return Observable.create &#123; observer in print("Emitting...") observer.onNext("🐶") observer.onNext("🐱") observer.onNext("🐵") return Disposables.create() &#125;&#125; deferredSequence .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) deferredSequence .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 12345678910Creating 1Emitting...🐶🐱🐵Creating 2Emitting...🐶🐱🐵 error创建一个可观察序列，但不发出任何正常的事件，只发出error事件并结束 12345let disposeBag = DisposeBag() Observable&lt;Int&gt;.error(TestError.test) .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) 1error(test) doOndoOn我感觉就是在直接onNext处理时候，先执行某个方法，doOnNext( :)方法就是在subscribe(onNext:)前调用，doOnCompleted(:)就是在subscribe(onCompleted:)前面调用的。 123456let disposeBag = DisposeBag() Observable.of("🍎", "🍐", "🍊", "🍋") .do(onNext: &#123; print("Intercepted:", $0) &#125;, onError: &#123; print("Intercepted error:", $0) &#125;, onCompleted: &#123; print("Completed") &#125;) .subscribe(onNext: &#123; print($0) &#125;,onCompleted: &#123; print("结束") &#125;) .addDisposableTo(disposeBag) 12345678910Intercepted: 🍎🍎Intercepted: 🍐🍐Intercepted: 🍊🍊Intercepted: 🍋🍋Completed结束 学会使用SubjectsSubjet是observable和Observer之间的桥梁，一个Subject既是一个Obserable也是一个Observer，他既可以发出事件，也可以监听事件。 PublishSubject当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件 12345678910let disposeBag = DisposeBag()let subject = PublishSubject&lt;String&gt;() subject.addObserver("1").addDisposableTo(disposeBag)subject.onNext("🐶")subject.onNext("🐱") subject.addObserver("2").addDisposableTo(disposeBag)subject.onNext("🅰️")subject.onNext("🅱️") 123456Subscription: 1 Event: next(🐶)Subscription: 1 Event: next(🐱)Subscription: 1 Event: next(🅰️)Subscription: 2 Event: next(🅰️)Subscription: 1 Event: next(🅱️)Subscription: 2 Event: next(🅱️) ReplaySubject当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小 12345678910let disposeBag = DisposeBag()let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) subject.addObserver("1").addDisposableTo(disposeBag)subject.onNext("🐶")subject.onNext("🐱") subject.addObserver("2").addDisposableTo(disposeBag)subject.onNext("🅰️")subject.onNext("🅱️") 1234567Subscription: 1 Event: next(🐶)Subscription: 1 Event: next(🐱)Subscription: 2 Event: next(🐱) //订阅之后还可以接受一次前面发出的事件Subscription: 1 Event: next(🅰️)Subscription: 2 Event: next(🅰️)Subscription: 1 Event: next(🅱️)Subscription: 2 Event: next(🅱️) BehaviorSubject当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件。 1234567891011121314let disposeBag = DisposeBag()let subject = BehaviorSubject(value: "🔴") subject.addObserver("1").addDisposableTo(disposeBag)subject.onNext("🐶")subject.onNext("🐱") subject.addObserver("2").addDisposableTo(disposeBag)subject.onNext("🅰️")subject.onNext("🅱️") subject.addObserver("3").addDisposableTo(disposeBag)subject.onNext("🍐")subject.onNext("🍊") 123456789101112131415Subscription: 1 Event: next(🔴)Subscription: 1 Event: next(🐶)Subscription: 1 Event: next(🐱)Subscription: 2 Event: next(🐱) //订阅之前的最后一个事件Subscription: 1 Event: next(🅰️)Subscription: 2 Event: next(🅰️)Subscription: 1 Event: next(🅱️)Subscription: 2 Event: next(🅱️)Subscription: 3 Event: next(🅱️) //订阅之前的最后一个事件Subscription: 1 Event: next(🍐)Subscription: 3 Event: next(🍐)Subscription: 2 Event: next(🍐)Subscription: 1 Event: next(🍊)Subscription: 3 Event: next(🍊)Subscription: 2 Event: next(🍊) PublishSubject, ReplaySubject和BehaviorSubject是不会自动发出completed事件的。 VariableVariable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable()拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。 12345678910let disposeBag = DisposeBag()let variable = Variable("🔴") variable.asObservable().addObserver("1").addDisposableTo(disposeBag)variable.value = "🐶"variable.value = "🐱" variable.asObservable().addObserver("2").addDisposableTo(disposeBag)variable.value = "🅰️"variable.value = "🅱️" 12345678910Subscription: 1 Event: next(🔴)Subscription: 1 Event: next(🐶)Subscription: 1 Event: next(🐱)Subscription: 2 Event: next(🐱)Subscription: 1 Event: next(🅰️)Subscription: 2 Event: next(🅰️)Subscription: 1 Event: next(🅱️)Subscription: 2 Event: next(🅱️)Subscription: 1 Event: completedSubscription: 2 Event: completed 联合操作联合操作就是把多个Observable流合成单个Observable流 startWith在发出事件消息之前，先发出某个特定的事件消息。比如发出事件2 ，3然后我startWith(1)，那么就会先发出1，然后2 ，3. 123456let disposeBag = DisposeBag() Observable.of("2", "3") .startWith("1") .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123123 merge合并两个Observable流合成单个Observable流，根据时间轴发出对应的事件 123456789101112131415161718192021let disposeBag = DisposeBag() let subject1 = PublishSubject&lt;String&gt;()let subject2 = PublishSubject&lt;String&gt;() Observable.of(subject1, subject2) .merge() .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) subject1.onNext("🅰️") subject1.onNext("🅱️") subject2.onNext("①") subject2.onNext("②") subject1.onNext("🆎") subject2.onNext("③") 123456🅰️🅱️①②🆎③ zip绑定超过最多不超过8个的Observable流，结合在一起处理。注意Zip是一个事件对应另一个流一个事件。 1234567891011121314151617181920let disposeBag = DisposeBag() let stringSubject = PublishSubject&lt;String&gt;()let intSubject = PublishSubject&lt;Int&gt;() Observable.zip(stringSubject, intSubject) &#123; stringElement, intElement in "\(stringElement) \(intElement)" &#125; .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) stringSubject.onNext("🅰️")stringSubject.onNext("🅱️") intSubject.onNext(1) intSubject.onNext(2) stringSubject.onNext("🆎")intSubject.onNext(3) 123🅰️ 1 将stringSubject和intSubject压缩到一起共同处理🅱️ 2🆎 3 combineLatest绑定超过最多不超过8个的Observable流，结合在一起处理。和Zip不同的是combineLatest是一个流的事件对应另一个流的最新的事件，两个事件都会是最新的事件，可将下图与Zip的图进行对比。 12345678910111213141516171819let disposeBag = DisposeBag() let stringSubject = PublishSubject&lt;String&gt;()let intSubject = PublishSubject&lt;Int&gt;() Observable.combineLatest(stringSubject, intSubject) &#123; stringElement, intElement in "\(stringElement) \(intElement)" &#125; .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) stringSubject.onNext("🅰️") stringSubject.onNext("🅱️")intSubject.onNext(1) intSubject.onNext(2) stringSubject.onNext("🆎") 123🅱️ 1🅱️ 2🆎 2 switchLatestswitchLatest可以对事件流进行转换，本来监听的subject1，我可以通过更改variable里面的value更换事件源。变成监听subject2了 1234567891011121314151617181920212223let disposeBag = DisposeBag() let subject1 = BehaviorSubject(value: "⚽️")let subject2 = BehaviorSubject(value: "🍎") let variable = Variable(subject1) variable.asObservable() .switchLatest() .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) subject1.onNext("🏈")subject1.onNext("🏀") variable.value = subject2 subject1.onNext("⚾️") subject2.onNext("🍐")variable.value = subject1subject2.onNext("田腾飞")subject1.onNext("沸腾天") 1234567⚽️🏈🏀🍎🍐⚾️沸腾天 变换操作map通过传入一个函数闭包把原来的sequence转变为一个新的sequence的操作 12345let disposeBag = DisposeBag()Observable.of(1, 2, 3) .map &#123; $0 * $0 &#125; .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 1231 每一个元素自己相乘49 flatMap将一个sequence转换为一个sequences，当你接收一个sequence的事件，你还想接收其他sequence发出的事件的话可以使用flatMap，她会将每一个sequence事件进行处理以后，然后再以一个新的sequence形式发出事件。和Swift中的意思差不多。 1234567891011121314151617181920212223242526let disposeBag = DisposeBag() struct Player &#123; var score: Variable&lt;Int&gt; //里面是一个Variable&#125; let 👦🏻 = Player(score: Variable(80)) let 👧🏼 = Player(score: Variable(90))let 😂 = Player(score: Variable(550)) let player = Variable(👦🏻) //将player转为Variable player.asObservable() .flatMap &#123; $0.score.asObservable() &#125;//转换成了一个新的序列 .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 👦🏻.score.value = 85 player.value = 👧🏼 //更换了value，相当于又添加了一个sequence，两个sequence都可以接收 👦🏻.score.value = 95👦🏻.score.value = 222player.value = 😂 👧🏼.score.value = 100 123456780859095222550100 flatMapLatestflatMapLatest只会接收最新的value事件，将上例改为flatMapLatest。结果为 1234808590550 scanscan就是给一个初始化的数，然后不断的拿前一个结果和最新的值进行处理操作。 12345678let disposeBag = DisposeBag() Observable.of(10, 100, 1000) .scan(1) &#123; aggregateValue, newValue in aggregateValue + newValue &#125; .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123111111111 过滤和约束filterfilter很好理解，就是过滤掉某些不符合要求的事件 1234567891011let disposeBag = DisposeBag() Observable.of( "🐱", "🐰", "🐶", "🐸", "🐱", "🐰", "🐹", "🐸", "🐱") .filter &#123; $0 == "🐱" &#125; .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123🐱🐱🐱 distinctUntilChangeddistinctUntilChanged就是当下一个事件与前一个事件是不同事件的事件才进行处理操作 123456let disposeBag = DisposeBag() Observable.of("🐱", "🐷", "🐱", "🐱", "🐱", "🐵", "🐱") .distinctUntilChanged() .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 12345🐱🐷🐱🐵🐱 elementAt只处理在指定位置的事件 123456let disposeBag = DisposeBag() Observable.of("🐱", "🐰", "🐶", "🐸", "🐷", "🐵") .elementAt(3) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 1🐸 single找出在sequence只发出一次的事件，如果超过一个就会发出error错误 1234Observable.of("🐱", "🐰", "🐶", "🐸", "🐷", "🐵") .single() .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 12🐱 //单一信号超过了一个Received unhandled error: /var/folders/hz/v15ld5mj0nqf83d21j13y0tw0000gn/T/./lldb/7229/playground107.swift:69:__lldb_expr_107 -&gt; Sequence contains more than one element. 1234Observable.of("🐱", "🐰", "🐶", "🐸", "🐷", "🐵") .single &#123; $0 == "🐸" &#125; //青蛙只有一个，completed .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) 1234Observable.of("🐱", "🐰", "🐶", "🐱", "🐰", "🐶") .single &#123; $0 == "🐰" &#125; //兔子有两个，会发出error .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) 1234Observable.of("🐱", "🐰", "🐶", "🐸", "🐷", "🐵") .single &#123; $0 == "🔵" &#125; //没有蓝色球，会发出error .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) take只处理前几个事件信号, 123456let disposeBag = DisposeBag() Observable.of("🐱", "🐰", "🐶", "🐸", "🐷", "🐵") .take(3) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123🐱🐰🐶 takeLast只处理后几个事件信号 123456let disposeBag = DisposeBag() Observable.of("🐱", "🐰", "🐶", "🐸", "🐷", "🐵") .takeLast(3) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123🐸🐷🐵 takeWhile当条件满足的时候进行处理 123456let disposeBag = DisposeBag() Observable.of(1, 2, 3, 4, 5, 6) .takeWhile &#123; $0 &lt; 4 &#125; .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123123 takeUntil接收事件消息，直到另一个sequence发出事件消息的时候。 12345678910111213141516171819let disposeBag = DisposeBag() let sourceSequence = PublishSubject&lt;String&gt;()let referenceSequence = PublishSubject&lt;String&gt;() sourceSequence .takeUntil(referenceSequence) .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) sourceSequence.onNext("🐱")sourceSequence.onNext("🐰")sourceSequence.onNext("🐶") referenceSequence.onNext("🔴") //停止接收消息 sourceSequence.onNext("🐸")sourceSequence.onNext("🐷")sourceSequence.onNext("🐵") 1234next(🐱)next(🐰)next(🐶)completed skip取消前几个事件 123456let disposeBag = DisposeBag() Observable.of("🐱", "🐰", "🐶", "🐸", "🐷", "🐵") .skip(2) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 1234🐶🐸🐷🐵 skipWhile满足条件的事件消息都取消 123456let disposeBag = DisposeBag() Observable.of(1, 2, 3, 4, 5, 6) .skipWhile &#123; $0 &lt; 4 &#125; .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 123456 skipWhileWithIndex满足条件的都被取消，传入的闭包同skipWhile有点区别而已 12345678let disposeBag = DisposeBag() Observable.of("🐱", "🐰", "🐶", "🐸", "🐷", "🐵") .skipWhileWithIndex &#123; element, index in index &lt; 3 &#125; .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) skipUntil直到某个sequence发出了事件消息，才开始接收当前sequence发出的事件消息 1234567891011121314151617181920let disposeBag = DisposeBag() let sourceSequence = PublishSubject&lt;String&gt;()let referenceSequence = PublishSubject&lt;String&gt;() sourceSequence .skipUntil(referenceSequence) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) sourceSequence.onNext("🐱")sourceSequence.onNext("🐰")sourceSequence.onNext("🐶") referenceSequence.onNext("🔴") sourceSequence.onNext("🐸")sourceSequence.onNext("🐷")sourceSequence.onNext("🐵")&#125; 数学操作toArray将sequence转换成一个array，并转换成单一事件信号，然后结束 123456let disposeBag = DisposeBag() Observable.range(start: 1, count: 10) .toArray() .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) 12next([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])completed reduce用一个初始值，对事件数据进行累计操作。reduce接受一个初始值，和一个操作符号 123456let disposeBag = DisposeBag() Observable.of(10, 100, 1000) .reduce(1, accumulator: +) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) 11111 concatconcat会把多个sequence和并为一个sequence，并且当前面一个sequence发出了completed事件，才会开始下一个sequence的事件。 在第一sequence完成之前，第二个sequence发出的事件都会被忽略，但会接收一完成之前的二发出的最后一个事件。不好解释，看例子说明 12345678910111213141516171819202122232425let disposeBag = DisposeBag() let subject1 = BehaviorSubject(value: "🍎")let subject2 = BehaviorSubject(value: "🐶") let variable = Variable(subject1) variable.asObservable() .concat() .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) subject1.onNext("🍐")subject1.onNext("🍊") variable.value = subject2 subject2.onNext("🐱") //1完成前，会被忽略subject2.onNext("teng") //1完成前，会被忽略subject2.onNext("fei") //1完成前的最后一个，会被接收 subject1.onCompleted() subject2.onNext("🐭") 12345next(🍎)next(🍐)next(🍊)next(fei)next(🐭) 连接性操作Connectable Observable有订阅时不开始发射事件消息，而是仅当调用它们的connect（）方法时。这样就可以等待所有我们想要的订阅者都已经订阅了以后，再开始发出事件消息，这样能保证我们想要的所有订阅者都能接收到事件消息。其实也就是等大家都就位以后，开始发出消息。 publish将一个正常的sequence转换成一个connectable sequence 1234567891011121314151617let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .publish() _ = intSequence .subscribe(onNext: &#123; print("Subscription 1:, Event: \($0)") &#125;) delay(2) &#123; _ = intSequence.connect() &#125; //相当于把事件消息推迟了两秒 delay(4) &#123; _ = intSequence .subscribe(onNext: &#123; print("Subscription 2:, Event: \($0)") &#125;)&#125; delay(6) &#123; _ = intSequence .subscribe(onNext: &#123; print("Subscription 3:, Event: \($0)") &#125;)&#125; 12345678910Subscription 1:, Event: 0Subscription 1:, Event: 1Subscription 2:, Event: 1Subscription 1:, Event: 2Subscription 2:, Event: 2Subscription 1:, Event: 3Subscription 3:, Event: 3Subscription 2:, Event: 3Subscription 1:, Event: 4Subscription 3:, Event: 4 replay将一个正常的sequence转换成一个connectable sequence，然后和replaySubject相似，能接收到订阅之前的事件消息。 1234567891011121314151617let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .replay(5) //接收到订阅之前的5条事件消息 _ = intSequence .subscribe(onNext: &#123; print("Subscription 1:, Event: \($0)") &#125;) delay(2) &#123; _ = intSequence.connect() &#125; delay(4) &#123; _ = intSequence .subscribe(onNext: &#123; print("Subscription 2:, Event: \($0)") &#125;)&#125; delay(8) &#123; _ = intSequence .subscribe(onNext: &#123; print("Subscription 3:, Event: \($0)") &#125;)&#125; multicast将一个正常的sequence转换成一个connectable sequence，并且通过特性的subject发送出去，比如PublishSubject，或者replaySubject，behaviorSubject等。不同的Subject会有不同的结果。 1234567891011121314151617let subject = PublishSubject&lt;Int&gt;() _ = subject .subscribe(onNext: &#123; print("Subject: \($0)") &#125;) let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .multicast(subject) _ = intSequence .subscribe(onNext: &#123; print("\tSubscription 1:, Event: \($0)") &#125;) delay(2) &#123; _ = intSequence.connect() &#125; delay(4) &#123; _ = intSequence .subscribe(onNext: &#123; print("\tSubscription 2:, Event: \($0)") &#125;)&#125; 错误处理catchErrorJustReturn遇到error事件的时候，就return一个值，然后结束 1234567891011121314let disposeBag = DisposeBag() let sequenceThatFails = PublishSubject&lt;String&gt;() sequenceThatFails .catchErrorJustReturn("😊") .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) sequenceThatFails.onNext("😬")sequenceThatFails.onNext("😨")sequenceThatFails.onNext("😡")sequenceThatFails.onNext("🔴")sequenceThatFails.onError(TestError.test) 123456next(😬)next(😨)next(😡)next(🔴)next(😊)completed catchError捕获error进行处理，可以返回另一个sequence进行订阅 1234567891011121314151617181920let disposeBag = DisposeBag() let sequenceThatFails = PublishSubject&lt;String&gt;()let recoverySequence = PublishSubject&lt;String&gt;() sequenceThatFails .catchError &#123; print("Error:", $0) return recoverySequence &#125; .subscribe &#123; print($0) &#125; .addDisposableTo(disposeBag) sequenceThatFails.onNext("😬")sequenceThatFails.onNext("😨")sequenceThatFails.onNext("😡")sequenceThatFails.onNext("🔴")sequenceThatFails.onError(TestError.test) recoverySequence.onNext("😊") 123456next(😬)next(😨)next(😡)next(🔴)Error: testnext(😊) retry遇见error事件可以进行重试，比如网络请求失败，可以进行重新连接 1234567891011121314151617181920212223242526let disposeBag = DisposeBag()var count = 1 let sequenceThatErrors = Observable&lt;String&gt;.create &#123; observer in observer.onNext("🍎") observer.onNext("🍐") observer.onNext("🍊") if count == 1 &#123; observer.onError(TestError.test) print("Error encountered") count += 1 &#125; observer.onNext("🐶") observer.onNext("🐱") observer.onNext("🐭") observer.onCompleted() return Disposables.create()&#125; sequenceThatErrors .retry(3) //不传入数字的话，只会重试一次 .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) debugdebug打印所有的订阅, 事件和disposals 12345sequenceThatErrors .retry(3) .debug() .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(disposeBag) RxSwift.Resources.total查看RxSwift所有资源的占用 1print(RxSwift.Resources.total) 啊，文章终于结束，这篇文章比较长，基本上涵盖了官方文档所有的概念，其中不免有些错误与疏漏，希望能在你学习RxSwift的时候能有一些参考价值吧！！！]]></content>
      <tags>
        <tag>RxSwift</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017时间管理]]></title>
    <url>%2F2017%2F01%2F06%2F2017%E6%97%B6%E9%97%B4%E7%B2%BE%E5%8A%9B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[这两天，听了罗胖2017年跨年演讲：”时间的朋友”，里面提到的许多观点还是能触达我的内心的。其中有一点就是：未来人类的战场就是时间的战场，将来人们最消费不起的就是时间。细思极恐下，遂做了如下的时间管理 强势 我们要明确一点：要让自己成长起来，必须要在自己身上多花时间 对家人：东西好就是好，不好就是不好，不要再说”随便”，”都可以”，”你看着办吧”之类的话，主动提出想法，观点 对朋友：那些没必要的应酬，不想参加的活动能拒绝的尽量去拒绝，不要碍于情面，浪费自己的时间，该拒绝即拒绝 对下属：该批评就批评，该奖赏就奖赏，有自己明确的态度，做事的风格，积极，主动的推动团队的发展 对工作：主动提出想法，据理力争，勇于接受挑战，承担责任，有很强的自驱力 效率 不要浪费时间在一些无谓的事情上面：比如说，淘宝为了2，3块钱，在几家比价了半天，跟商家讨价了半天，其实早点做完，做其他事情，创造价值远超过那点钱 要清楚自己什么时间做事的效率高，什么时间做事的效率低，效率高的时候多安排重要的事情，效率低的时候可以做一些简单的，甚至放松的事 任务 明确自己定下的事情就必须要做，克制拖延症 遇事不要急，一件件做好，不要做了一半扔在那边，结果就不管了 明确事情的优先级，优先处理重要的事 分配 许多事情，不一定要亲力亲为，找到合适的人，把事情放心的交给他做，甚至，在自己可承受的范围内，花钱请人来做 多做自己擅长的，能创造价值的事情，那些不擅长，找信的过的人来帮忙 总结 不要做老好人，要有明确的态度倾向，什么事该做，什么事不该做，什么人该帮，什么人不该帮 自己时间不够用的情况下，要舍得花钱买别人的时间，任何事不一定要自己亲力亲为，要懂得分配，安排 身体是革命的本钱，工作的同时要注意自己的身体，不熬夜，多健身 做一个自律的人，读书，练字，健身，持续，坚持，提升自我修养 最后，说了再多，一定要去完成，不然，然并卵。]]></content>
  </entry>
</search>
